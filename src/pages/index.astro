---
import type {
    HomeEntry,
    ProductCategoryEntryMetaItem,
    ProductEntry,
} from '../../bcms/types/ts';
import { productToLite } from '../utils/product';

import Layout from '../layouts/Layout.astro';
import HomePageWrapper from '../components/home-page/PageWrapper';
import { bcmsPrivate } from '../bcms-private';
import { bcmsPublic } from '../bcms-public';

// 1. Definimos la interfaz para que TypeScript no se queje
interface PersonajeD1 {
    id_personaje: number;
    nombre_personaje: string;
    img_personaje: string;
    id_universo: number;
}

// 2. CONEXIÓN D1 (Solo funciona en el servidor de Cloudflare)
const { DB } = (Astro.locals as any).runtime.env;

// 3. Datos de Home y Productos (BCMS)
const home = (await bcmsPrivate.entry.getById('home', 'home')) as HomeEntry;
const homeMeta = home.meta.en as any;

const products = (await bcmsPrivate.entry.getAll('product')) as ProductEntry[];
const productsLite = products.map((e) => productToLite(e));

// 4. CONSULTA SQL A TU NUEVA TABLA
// Intentamos obtener los personajes de la base de datos D1
let personajesD1: PersonajeD1[] = [];
try {
    const { results } = await DB.prepare("SELECT * FROM personajes").all();
    personajesD1 = results as unknown as PersonajeD1[];
} catch (e) {
    console.error("Error al conectar con D1:", e);
}

// 5. Procesamiento de categorías (Convertimos personajes de D1 en categorías de la web)
const categories = personajesD1.map((p) => {
    
    // Filtramos productos de BCMS que pertenezcan a este personaje
    const productsWithThisChar = products.filter((prod) => {
        const pMeta = prod.meta?.en as any;
        return (
            pMeta?.nom_personaje_filt?._id === p.id_personaje.toString() ||
            pMeta?.nom_personaje_filt?.title === p.nombre_personaje
        );
    });

    const fallbackImage = productsWithThisChar[0]?.meta?.en?.gallery?.[0];

    return {
        meta: {
            title: p.nombre_personaje,
            slug: p.nombre_personaje.toLowerCase().replace(/\s+/g, '-'),
            // Usamos la imagen de D1, si no hay, usamos la del primer producto de BCMS
            gallery: p.img_personaje 
                ? [{ src: p.img_personaje, alt: p.nombre_personaje }] 
                : (fallbackImage ? [fallbackImage] : [])
        },
        productsCount: productsWithThisChar.length,
    };
}).filter(item => item.meta.gallery.length > 0);

// 6. Configuración de Filtros
const filters = {
    categories: products.reduce((acc, e) => {
        e.meta.en?.categories.forEach((i) => {
            if (i.meta.en && !acc.find((c) => c.slug === i.meta.en?.slug)) {
                acc.push(i.meta.en);
            }
        });
        return acc;
    }, [] as ProductCategoryEntryMetaItem[]),
    
    // Usamos los nombres de personajes de D1 como filtro de "Género/Personaje"
    genders: personajesD1.map(p => ({
        title: p.nombre_personaje,
        slug: p.nombre_personaje.toLowerCase().replace(/\s+/g, '-')
    })),
};

const clientConfig = bcmsPublic.getConfig();
---

<Layout title={`${homeMeta.seo?.title || homeMeta.title} | DC Impresiones 3D`}>
    <div style="display:none">Conexión D1 establecida con {personajesD1.length} personajes.</div>

    <HomePageWrapper
        client:load
        bcms={clientConfig}
        meta={homeMeta}
        categories={categories as any}
        products={productsLite}
        filters={filters as any}
    />
</Layout>